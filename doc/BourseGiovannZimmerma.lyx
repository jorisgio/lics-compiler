#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Rapport final du projet de microprocesseur
\end_layout

\begin_layout Author
Florian Bourse, Joris Giovannangeli, Théo Zimmermann
\end_layout

\begin_layout Date
Janvier 2012
\end_layout

\begin_layout Section
Langage de description de circuits
\end_layout

\begin_layout Subsection
Les spécifications
\end_layout

\begin_layout Subsubsection
Principes généraux
\end_layout

\begin_layout Standard
Le langage que nous avons créé est un langage hiérarchisé.
 Il permet de définir des portes logiques complexes et de les combiner entre
 elles dans la définition d'autres portes.
 Le circuit lui-même est vu comme une porte.
\end_layout

\begin_layout Standard
Le programme d'un circuit consiste en la description successive des portes.
\end_layout

\begin_layout Standard
Le circuit est donné par une porte de nom 
\begin_inset Quotes eld
\end_inset

Start
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Définition d'une porte
\end_layout

\begin_layout Standard
Une porte est la donnée de son nom, de la liste de ses variables d'entrée,
 d'un ensemble d'instructions décrivant la manière dont on combine les variables
, et de la liste de ses variables de sorties.
\end_layout

\begin_layout Subparagraph
Contenu
\end_layout

\begin_layout Standard
Sont disponibles les portes logiques élémentaires 
\emph on
not
\emph default
, 
\emph on
and
\emph default
, 
\emph on
or
\emph default
, 
\emph on
xor
\emph default
 et 
\emph on
mux
\emph default
, les primitives 
\emph on
reg
\emph default
 pour les registres (1 bit) et 
\emph on
lw
\emph default
 pour lire dans la ROM, les constantes 
\emph on
true
\emph default
 et 
\emph on
false
\emph default
.
\end_layout

\begin_layout Subparagraph
Utilisation
\end_layout

\begin_layout Standard
Il est possible d'assigner des expressions complexes à des variables ou
 dans des tableaux.
\end_layout

\begin_layout Standard
Les variables sont définies à l'occasion des assignations.
\end_layout

\begin_layout Standard
En revanche, les tableaux doivent être déclarés avant d'être utilisés.
\end_layout

\begin_layout Standard
Les variables définies à l'intérieur d'une porte ainsi que les variables
 d'entrée sont utilisables dans les expressions qui se trouvent dans cette
 porte.
 L'ordre n'importe pas.
 Cependant, pour que le circuit compile, il convient de ne pas créer de
 boucle combinatoire.
\end_layout

\begin_layout Standard
Les variables définies à l'intérieur d'une porte sont utilisables pour en
 décrire les sorties.
\end_layout

\begin_layout Standard
Il est possible de fournir un sous-tableau partout où est attendue une liste
 de variables.
\end_layout

\begin_layout Standard
A contrario, il est indispensable de donner un sous-tableau comme sortie
 de certaines instructions (appel d'une porte et de la primitive 
\emph on
lw
\emph default
).
\end_layout

\begin_layout Standard
Enfin, une fonction 
\emph on
for
\emph default
 est disponible et elle utilise des indices entiers sur lesquels sont permis
 les calculs de l'arithmétique élémentaire.
\end_layout

\begin_layout Subparagraph
Syntaxe
\end_layout

\begin_layout Standard
Le code peut être émaillé de commentaires, 
\begin_inset Quotes eld
\end_inset

à la C
\begin_inset Quotes erd
\end_inset

, entre les caractères 
\begin_inset Quotes eld
\end_inset

/*
\begin_inset Quotes erd
\end_inset

 et 
\begin_inset Quotes eld
\end_inset

*/
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Le nom de la porte doit commencer par une majuscule.
 Il est suivit des caractères 
\begin_inset Quotes eld
\end_inset

<-
\begin_inset Quotes erd
\end_inset

 puis, entre parenthèses, de la liste des entrées séparées par des virgules.
\end_layout

\begin_layout Standard
Les entrées sont soit des variables dont on donne le nom, soit des tableaux
 dont on donne le nom puis la taille entre crochets.
\end_layout

\begin_layout Standard
Les instructions sont soit des déclarations de tableaux avec le mot clé
 
\emph on
array
\emph default
 suivi du nom du tableau et de sa taille entre crochets, soit des boucles
 
\emph on
for
\emph default
 avec, entre parenthèses et séparés par des virgules, le nom de l'indice,
 sa valeur initiale et sa valeur finale puis, entre accolades, le corps
 de la boucle, soit des assignations de la valeur d'une expression à une
 variable ou un sous-tableau avec l'opérateur 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Un sous-tableau est donné par son nom, suivi, entre crochets, d'un intervalle,
 c'est-à-dire de ses deux extrémités séparées par les caractères 
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset

 .
\end_layout

\begin_layout Standard
Une expression est la combinaison des portes logiques et primitives de base,
 soit infixes, soit préfixes, prenant leurs arguments entre parenthèses
 quand il y en a plusieurs.
 On peut aussi faire appel à des portes précédemment définies en passant
 les entrées avec les caractères 
\begin_inset Quotes eld
\end_inset

<-
\begin_inset Quotes erd
\end_inset

 suivis d'une liste de variables entre parenthèses.
\end_layout

\begin_layout Subsection
Le compilateur
\end_layout

\begin_layout Standard
Le compilateur traduit le programme dans un langage intermédiaire de description
 de net-list topologiquement triée.
\end_layout

\begin_layout Standard
Après avoir parsé le code, le compilateur effectue de nombreuses vérifications
 sémantiques.
 Cette étape est l'occasion de lister les variables qui sont définies à
 l'intérieur de chaque porte.
 Puis il crée un graphe représentant le circuit.
 Ceci se fait en deux étapes : on crée les noeuds internes aux portes (correspon
dants aux variables locales) et on relie les différentes portes qu'on aura
 instancié en créant des arêtes supplémentaires.
 Afin de pouvoir trier topologiquement le graphe ainsi obtenu avec un algorithme
 usuel, les registres sont préalablement 
\begin_inset Quotes eld
\end_inset

éclatés
\begin_inset Quotes erd
\end_inset

 entre une entrée et une sortie.
 On mémorise dans des tableaux la correspondance qu'il y a entre entrées
 et sorties de registres.
 A l'occasion du tri, une erreur est déclenchée en cas de circuit combinatoire.
 La dernière étape consiste à générer la net-list, notamment en faisant
 correspondre à chaque noeud du graphe une variable du langage intermédiaire,
 qui sera représentée par un numéro.
\end_layout

\begin_layout Standard
Nous avons rajouté une option permettant de faire une réallocation automatique
 des numéros de variables afin de minimiser, lors de la simulation, la taille
 de l'environnement.
 Il s'agit d'une coloration de graphe d'interférence, résolue avec un algorithme
 glouton.
\end_layout

\begin_layout Standard
Le compilateur est sans aucun doute la partie qui nous aura demandé le plus
 de travail vu les larges possibilités dont nous avons muni notre langage.
 Il a fallu sans cesse le retoucher et y ajouter des fonctionnalités.
 Malgré les nombreux tests que nous avions créés, l'écriture du processeur
 nous a conduit à trouver de nouveaux bugs, étant donné que nous n'avions
 jamais pu tester le compilateur sur un circuit de cette ampleur.
\end_layout

\begin_layout Subsection
Le simulateur
\end_layout

\begin_layout Paragraph
Principe de fonctionnement
\end_layout

\begin_layout Standard
Le simulateur exécute linéairement les instructions fournies dans un fichier
 binaire produit par le compilateur.
 Il prend en entrées les entrées du circuit et différentes options d'affichage
 (en console, en décimal et en mode graphique) ainsi que le nombre de cycles
 à effectuer.
\end_layout

\begin_layout Standard
Un environnement est maintenu avec les valeurs des différentes variables
 intermédiaires et les valeurs des registres sont transmises d'un cycle
 sur le suivant.
\end_layout

\begin_layout Standard
La ROM est représentée en mémoire par un tableau de listes de booléens.
 Les adresses sont fournies en binaires sous forme de liste de booléens.
\end_layout

\begin_layout Paragraph
Options supplémentaires
\end_layout

\begin_layout Standard
Une option permet de précharger la ROM avec le contenu d'un fichier.
 Nous avons aussi rajouté un mode de fonctionnement 
\begin_inset Quotes eld
\end_inset

horloge
\begin_inset Quotes erd
\end_inset

, pour des circuits à une entrée, qui met la valeur de cette entrée à 1
 toutes les secondes (et 0 le reste du temps).
 Ce mode permet d'exécuter la montre en temps réel.
 Inversement, il suffit de passer une entrée constante égale à 1 pour exécuter
 la montre en accéléré.
\end_layout

\begin_layout Section
Le microprocesseur
\end_layout

\begin_layout Subsection
Description générale
\end_layout

\begin_layout Standard
Le microprocesseur est largement inspiré d'un microprocesseur MIPS mais
 nous avons gardé un minimum d'instructions, utiles pour réaliser le programme
 de la montre.
\end_layout

\begin_layout Standard
L'ALU calcule l'addition, la soustraction, les tests de comparaison et les
 opérations logiques bit à bit.
\end_layout

\begin_layout Standard
Les instructions sont chargées depuis la ROM à partir de l'adresse 0.
\end_layout

\begin_layout Standard
Nous avons rajouté des instructions de branchement et de saut inconditionnel.
\end_layout

\begin_layout Standard
L'unité de contrôle décode les instructions suivant les mêmes conventions
 que MIPS.
\end_layout

\begin_layout Standard
Le microprocesseur possède 32 registres ; le registre 
\emph on
$31
\emph default
 est réservé pour enregistrer la valeur du timestamp.
 Le microprocesseur prend une entrée, un top d'horloge, et met à jour le
 timestamp automatiquement.
 Il renvoie systématiquement en sortie les valeurs de 14 registres déterminés
 qui correspondent aux unités, dizaines, etc des heures, minutes, secondes,
 jour, mois, années.
\end_layout

\begin_layout Subsection
Assembleur
\end_layout

\begin_layout Standard
Nous disposons d'un assembleur qui est inspiré de MIPS.
 Les instructions fournies sont : 
\emph on
add
\emph default
, 
\emph on
sub
\emph default
, 
\emph on
and
\emph default
, 
\emph on
or
\emph default
, 
\emph on
li
\emph default
, 
\emph on
beq
\emph default
, 
\emph on
j
\emph default
 et il est possible de définir des étiquettes dans le code.
 Le programme assembleur se charge de traduire cela en binaire, et génère
 un fichier 
\begin_inset Quotes eld
\end_inset

a.out
\begin_inset Quotes erd
\end_inset

 dans le format demandé par le simulateur pour précharger la ROM.
 Ainsi, un programme exécuté sur le microprocesseur sera systématiquement
 préchargé dans la ROM de cette manière.
\end_layout

\begin_layout Paragraph
Conventions détaillés de l'assembleur
\end_layout

\begin_layout Standard
Les instructions sont codées sur 32bits, décomposées comme suit :
\end_layout

\begin_layout LyX-Code
[ 3bits ] [ 29 bits ]
\end_layout

\begin_layout Standard
Les 3 premiers bits contiennent l'opcode de l'instruction, c'est à dire
 son type.
 Au vu du jeu d'instruction réduit, ces bits permettent de donner directement
 les valeurs de contrôle sans se préoccuper de mettre en place une table
 de vérité.
 On obtient les valeurs de contrôle suivantes :
\end_layout

\begin_layout Description
datasrc : choisit l'entrée du bloc de registre contenant les données à écrire.
 0 : sortie de l'ALU.
 1 : la constante étendue à 32 bits contenue dans les 16 bits bas de l'instructi
on.
 Défini comme le 3ème bit de l'opcode.
\end_layout

\begin_layout Description
regWrite : choisit si on va écrire ou non dans les registres 0 : on garde
 les valeurs des registres, 1 : on écrit dans 1 registre.
 Défini comme l'opposé du premier bit de l'opcode.
\end_layout

\begin_layout Description
jump : choisit la valeur du prochain PC : soit celle venant de l'ALU, soit
 celle venant des 29 bits de la partie basse de l'instruction.
 1 : on prend la valeur de l'instruction.
 0 : on prend la valeur de l'ALU .
 Défini comme le 2ème bit de l'opcode.
\end_layout

\begin_layout Description
branch (br) : choisit la valeur du prochain PC 0 : on prend PC + 1 , 1 :
 on prend l'adresse donnée par l'instruction de branchement étendue à 32bits.
 Défini comme le premier bit d'opcode.
\end_layout

\begin_layout Description
writeReg : choisit la source de l'adresse du registre à écrire, sur 5 bits.
 0 : partie 16-20 de l'instruction, 1 : partie 11-15 de l'instruction.
 Défini comme l'opposé du 3ème bit d'opcode .
\end_layout

\begin_layout Subparagraph
R type
\end_layout

\begin_layout Standard
Les instrucions arithmétiques et logiques.
\end_layout

\begin_layout LyX-Code
[ 3bits ] [3bits] [ 5 bits ] [ 5 bits ] [ 5 bits ] [ 5 bits] [ 6bits ] 
\end_layout

\begin_layout LyX-Code
opcode      vide     rs          rt         rd        vide    ALUfunc
\end_layout

\begin_layout Standard
Les 6 bits d'ALUfunc choisissent l'opération que l'ALU doit effectuer.
 Seuls les 3 bits de poids faible comptent ALUopérations : 
\end_layout

\begin_layout Description
000 : AND 
\end_layout

\begin_layout Description
100 : OR 
\end_layout

\begin_layout Description
010 : ADD 
\end_layout

\begin_layout Standard
L'opcode est 000, donc : 
\end_layout

\begin_layout Itemize
datasrc = 0, résultat de l'instrution en entrée des registres
\end_layout

\begin_layout Itemize
regWrite = 1 : on écrit le résultat dans le registre,
\end_layout

\begin_layout Itemize
jump = 0 : on ne fait pas de saut, 
\end_layout

\begin_layout Itemize
branch = 0 : on prend l'instruction suivante, 
\end_layout

\begin_layout Itemize
writeReg = 1 : on prend la partie rd 11-15 de l'instruction comme registre
 de destination.
 
\end_layout

\begin_layout Subparagraph
Load 
\end_layout

\begin_layout Standard
load immediate
\end_layout

\begin_layout LyX-Code
[ 3bits ] [ 3bits ] [ 5bits] [ 5 bits ] [ 16 bits ]
\end_layout

\begin_layout LyX-Code
opcode     vide      vide      rd         entier 
\end_layout

\begin_layout Standard
L'opcode est : 001, donc : 
\end_layout

\begin_layout Itemize
datasrc = 1, partie basse de l'instruction en entrée des registres, 
\end_layout

\begin_layout Itemize
regWrite = 1, on écrit dans le registre 
\end_layout

\begin_layout Itemize
jump = 0, 
\end_layout

\begin_layout Itemize
branch = 0, on prend l'instruction suivante pour PC 
\end_layout

\begin_layout Itemize
writeReg = 0, on prend la partie rd 26-20 comme destination
\end_layout

\begin_layout Subparagraph
Jump
\end_layout

\begin_layout Standard
Les instructions de saut, avec juste jump dans les faits.
\end_layout

\begin_layout LyX-Code
[ 3bits ] [       29 bits          ] 
\end_layout

\begin_layout LyX-Code
  opcode     addresse du futur PC 
\end_layout

\begin_layout Standard
l'opcode est 110, donc 
\end_layout

\begin_layout Itemize
datasrc = 0, 
\end_layout

\begin_layout Itemize
regWrite = 0,
\end_layout

\begin_layout Itemize
jump = 1, 
\end_layout

\begin_layout Itemize
branch = 1 (Don't care, puisque jump = 1),
\end_layout

\begin_layout Itemize
writeReg = 1 (Don't care, car regWrite = 0)
\end_layout

\begin_layout Subparagraph
Branch 
\end_layout

\begin_layout Standard
L'instruction 
\emph on
beq.
\end_layout

\begin_layout LyX-Code
[ 3 bits ] [ 3bits ] [ 5bits ] [ 5bits ] [ 16 bits ]
\end_layout

\begin_layout LyX-Code
  opcode    vide       rs        rt        offset 
\end_layout

\begin_layout Standard
L'opcode est 100, donc : 
\end_layout

\begin_layout Itemize
datasrc = 0
\end_layout

\begin_layout Itemize
regWrite = 0
\end_layout

\begin_layout Itemize
jump = 0
\end_layout

\begin_layout Itemize
branch = 1
\end_layout

\begin_layout Itemize
writeReg = 1 (Don't care)
\end_layout

\begin_layout Section
Le programme de la montre
\end_layout

\begin_layout Standard
Le programme de la montre est assez simple:
\end_layout

\begin_layout Standard
il garde dans des registres les valeurs des chiffres à retenir: unités et
 dizaines des secondes, minutes, heures, jours, mois, années, ainsi que
 les unités et les dizaines des siècles.
 Elle comprend également un registre qui permet de compter modulo 4 pour
 savoir si l'année est bissextile ou non, ainsi que des registres contenant
 le nombre d'heures, de mois et de jours, afin de faciliter la remise à
 zéro du compteur en temps voulu.
 Pour connaître le nombre de jours dans un mois, on se donne aussi un registre
 dans lequel on stocke cette information, il est mis à jour à chaque changement
 de mois.
\end_layout

\begin_layout Standard
Ensuite, on effectue une simple boucle, qui incrémente le chiffre des unités
 des secondes à chaque fois que le timestamp a changé, celui-ci étant lié
 aux entrées fournies par le simulateur, et qui transmet la retenue s'il
 dépasse le maximum autorisé (9), qui va se propager jusqu'à actualisation
 complète de la date.
\end_layout

\end_body
\end_document
